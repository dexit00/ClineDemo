# ECShop 認証機能設計書

## 1. 機能概要

### 1.1 機能目的
ユーザーの登録、ログイン、認証、認可機能を提供し、セキュアなECサイト運営を実現する。

### 1.2 主要機能
- ユーザー登録
- ログイン・ログアウト
- JWT トークン認証
- プロフィール管理
- 権限管理（一般ユーザー・管理者）
- パスワードハッシュ化

### 1.3 対象ユーザー
- **一般ユーザー**: 会員登録・ログイン・プロフィール管理
- **管理者**: 全ユーザー管理・権限設定

## 2. システム構成

### 2.1 アーキテクチャ図
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  LoginForm      │    │  AuthController │    │   JWT Service   │
│  RegisterForm   │◄──►│                 │◄──►│                 │
│  UserProfile    │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │                        │
                                ▼                        ▼
                       ┌─────────────────┐    ┌─────────────────┐
                       │   User Entity   │    │  BCrypt Hash    │
                       │                 │    │                 │
                       └─────────────────┘    └─────────────────┘
```

### 2.2 認証フロー
```
1. ユーザー登録/ログイン
   ↓
2. パスワード検証（BCrypt）
   ↓
3. JWT トークン生成
   ↓
4. クライアントに返却
   ↓
5. localStorage に保存
   ↓
6. API リクエスト時にヘッダーに付与
   ↓
7. サーバーでトークン検証
   ↓
8. 認証・認可チェック
```

## 3. データモデル

### 3.1 User エンティティ
```csharp
public class User
{
    public int Id { get; set; }                    // ユーザーID（主キー）
    
    [Required]
    [StringLength(50)]
    public string Username { get; set; }           // ユーザー名（必須、最大50文字、ユニーク）
    
    [Required]
    [EmailAddress]
    [StringLength(100)]
    public string Email { get; set; }              // メールアドレス（必須、最大100文字、ユニーク）
    
    [Required]
    public string PasswordHash { get; set; }       // パスワードハッシュ（必須）
    
    [StringLength(50)]
    public string FirstName { get; set; }          // 名（必須、最大50文字）
    
    [StringLength(50)]
    public string LastName { get; set; }           // 姓（必須、最大50文字）
    
    public DateTime CreatedAt { get; set; }        // 作成日時
    public bool IsAdmin { get; set; }              // 管理者フラグ（デフォルト: false）
}
```

### 3.2 認証関連 DTO
```csharp
// ユーザー登録リクエスト
public class RegisterRequest
{
    [Required]
    [StringLength(50)]
    public string Username { get; set; }           // ユーザー名
    
    [Required]
    [EmailAddress]
    [StringLength(100)]
    public string Email { get; set; }              // メールアドレス
    
    [Required]
    [MinLength(6)]
    public string Password { get; set; }           // パスワード（最低6文字）
    
    [Required]
    [StringLength(50)]
    public string FirstName { get; set; }          // 名
    
    [Required]
    [StringLength(50)]
    public string LastName { get; set; }           // 姓
}

// ログインリクエスト
public class LoginRequest
{
    [Required]
    public string Username { get; set; }           // ユーザー名
    
    [Required]
    public string Password { get; set; }           // パスワード
}

// 認証レスポンス
public class AuthResponse
{
    public string Token { get; set; }              // JWT トークン
    public UserDto User { get; set; }              // ユーザー情報
}

// ユーザー情報 DTO
public class UserDto
{
    public int Id { get; set; }                    // ユーザーID
    public string Username { get; set; }           // ユーザー名
    public string Email { get; set; }              // メールアドレス
    public string FirstName { get; set; }          // 名
    public string LastName { get; set; }           // 姓
    public DateTime CreatedAt { get; set; }        // 作成日時
    public bool IsAdmin { get; set; }              // 管理者フラグ
}
```

## 4. API仕様

### 4.1 ユーザー登録
- **エンドポイント**: `POST /api/auth/register`
- **認証**: 不要
- **機能**: 新規ユーザーを登録し、JWTトークンを返す

#### リクエスト例
```json
{
  "username": "testuser",
  "email": "test@example.com",
  "password": "password123",
  "firstName": "太郎",
  "lastName": "田中"
}
```

#### レスポンス例 (200 OK)
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": 1,
    "username": "testuser",
    "email": "test@example.com",
    "firstName": "太郎",
    "lastName": "田中",
    "createdAt": "2024-01-01T00:00:00Z",
    "isAdmin": false
  }
}
```

#### 処理フロー
1. リクエストボディのバリデーション
2. ユーザー名・メールアドレスの重複チェック
3. パスワードのBCryptハッシュ化
4. ユーザーエンティティの作成・保存
5. JWT トークンの生成
6. レスポンス返却

### 4.2 ログイン
- **エンドポイント**: `POST /api/auth/login`
- **認証**: 不要
- **機能**: ユーザー認証を行い、JWTトークンを返す

#### リクエスト例
```json
{
  "username": "testuser",
  "password": "password123"
}
```

#### レスポンス例 (200 OK)
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": 1,
    "username": "testuser",
    "email": "test@example.com",
    "firstName": "太郎",
    "lastName": "田中",
    "createdAt": "2024-01-01T00:00:00Z",
    "isAdmin": false
  }
}
```

#### 処理フロー
1. ユーザー名でユーザー検索
2. BCryptでパスワード検証
3. 認証成功時、JWT トークン生成
4. レスポンス返却

### 4.3 プロフィール取得
- **エンドポイント**: `GET /api/auth/profile`
- **認証**: 必要
- **機能**: 現在のユーザー情報を取得

#### レスポンス例 (200 OK)
```json
{
  "id": 1,
  "username": "testuser",
  "email": "test@example.com",
  "firstName": "太郎",
  "lastName": "田中",
  "createdAt": "2024-01-01T00:00:00Z",
  "isAdmin": false
}
```

## 5. JWT トークン設計

### 5.1 JWT 設定
```json
{
  "JwtSettings": {
    "SecretKey": "your-secret-key-here",
    "Issuer": "ECShop",
    "Audience": "ECShop-Users",
    "ExpiryInHours": 24
  }
}
```

### 5.2 JWT ペイロード
```json
{
  "sub": "1",                    // ユーザーID (NameIdentifier)
  "unique_name": "testuser",     // ユーザー名 (Name)
  "email": "test@example.com",   // メールアドレス (Email)
  "role": "User",                // ロール (Role) - "User" or "Admin"
  "iat": 1640995200,             // 発行時刻
  "exp": 1641081600              // 有効期限
}
```

## 5. Controller・Action別処理設計

### 5.1 AuthController

#### POST /api/auth/register (Register Action)
**処理概要**: 新規ユーザーを登録し、JWTトークンを返す

**リクエスト**
- **リクエストボディ**:
```json
{
  "username": "testuser",
  "email": "test@example.com",
  "password": "password123",
  "firstName": "太郎",
  "lastName": "田中"
}
```

**レスポンス** (200 OK)
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": 1,
    "username": "testuser",
    "email": "test@example.com",
    "firstName": "太郎",
    "lastName": "田中",
    "createdAt": "2024-01-01T00:00:00Z",
    "isAdmin": false
  }
}
```

**処理フロー**:
1. **リクエストボディ取得**: JSONからusername、email、password、firstName、lastNameを取得
2. **バリデーション**: 
   - usernameが空でないこと（最大50文字）
   - emailが有効なメールアドレス形式であること（最大100文字）
   - passwordが6文字以上であること
   - firstName、lastNameが空でないこと（各最大50文字）
3. **重複チェック**: 
   - ECShopContextを使用してUsersテーブルでusernameの重複をチェック
   - 同様にemailの重複をチェック
4. **パスワードハッシュ化**: BCrypt.Net.BCrypt.HashPasswordでパスワードをハッシュ化
5. **ユーザー作成**: 新しいUserエンティティを作成し、CreatedAtに現在日時を設定
6. **データベース保存**: ECShopContextを使用してUsersテーブルに追加
7. **JWT生成**: ユーザー情報からJWTトークンを生成
8. **レスポンス作成**: AuthResponseオブジェクトを作成してJSON形式で返却

**エラー処理**: 
- ユーザー名重複 → 400 Bad Request
- メールアドレス重複 → 400 Bad Request
- バリデーションエラー → 400 Bad Request

#### POST /api/auth/login (Login Action)
**処理概要**: ユーザー認証を行い、JWTトークンを返す

**リクエスト**
- **リクエストボディ**:
```json
{
  "username": "testuser",
  "password": "password123"
}
```

**レスポンス** (200 OK)
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": 1,
    "username": "testuser",
    "email": "test@example.com",
    "firstName": "太郎",
    "lastName": "田中",
    "createdAt": "2024-01-01T00:00:00Z",
    "isAdmin": false
  }
}
```

**処理フロー**:
1. **リクエストボディ取得**: JSONからusernameとpasswordを取得
2. **ユーザー検索**: ECShopContextを使用してUsersテーブルからusernameでユーザーを検索
3. **ユーザー存在チェック**: ユーザーが見つからない場合は認証失敗
4. **パスワード検証**: BCrypt.Net.BCrypt.Verifyで平文パスワードとハッシュを比較
5. **認証判定**: パスワードが一致しない場合は認証失敗
6. **JWT生成**: 認証成功時、ユーザー情報からJWTトークンを生成
7. **レスポンス作成**: AuthResponseオブジェクトを作成してJSON形式で返却

**エラー処理**: 
- 認証失敗（ユーザー不存在・パスワード不一致） → 400 Bad Request
- バリデーションエラー → 400 Bad Request

#### GET /api/auth/profile (GetProfile Action)
**処理概要**: 現在のユーザー情報を取得

**リクエスト**
- **ヘッダー**: `Authorization: Bearer {JWT_TOKEN}`

**レスポンス** (200 OK)
```json
{
  "id": 1,
  "username": "testuser",
  "email": "test@example.com",
  "firstName": "太郎",
  "lastName": "田中",
  "createdAt": "2024-01-01T00:00:00Z",
  "isAdmin": false
}
```

**処理フロー**:
1. **JWT解析**: Authorizationヘッダーからトークンを取得
2. **クレーム取得**: JWTトークンからNameIdentifierクレーム（ユーザーID）を取得
3. **ID検証**: クレーム値が存在し、整数に変換可能かチェック
4. **ユーザー検索**: ECShopContextを使用してUsersテーブルから指定IDのユーザーを検索
5. **存在チェック**: ユーザーが見つからない場合は404エラー
6. **レスポンス作成**: UserDtoオブジェクトを作成してJSON形式で返却

**エラー処理**: 
- 認証情報不正（トークン無効・期限切れ） → 401 Unauthorized
- ユーザー不存在 → 404 Not Found

### 5.2 JWT生成処理設計

#### JWT生成の処理フロー
**Controller内での実装手順**:
1. **設定値取得**
   - IConfigurationを使用してappsettings.jsonからJwtSettings セクションを取得
   - SecretKey（署名用秘密鍵）、Issuer（発行者）、Audience（対象者）を取得
   - ExpiryInHours（有効期限）を取得（デフォルト24時間）

2. **署名情報作成**
   - 秘密鍵をUTF-8バイト配列に変換（Encoding.UTF8.GetBytes）
   - SymmetricSecurityKeyオブジェクトを作成
   - HMAC-SHA256アルゴリズムでSigningCredentialsを作成

3. **クレーム情報設定**
   - Claimオブジェクトのリストを作成
   - NameIdentifier: ユーザーIDを文字列として設定
   - Name: ユーザー名を設定
   - Email: メールアドレスを設定
   - Role: 管理者フラグに応じて"Admin"または"User"を設定

4. **トークン生成**
   - JwtSecurityTokenオブジェクトを作成
   - 発行者、対象者、クレーム、有効期限（DateTime.UtcNow.AddHours）、署名情報を設定
   - JwtSecurityTokenHandlerを使用してWriteTokenメソッドでトークン文字列に変換
   - 生成されたトークン文字列を返却

## 6. パスワードセキュリティ

### 6.1 BCrypt ハッシュ化処理

#### パスワードハッシュ化処理
**HashPassword メソッドの処理内容**:
1. 入力されたパスワード文字列を受け取り
2. BCrypt.Net.BCrypt.HashPasswordメソッドを呼び出し
3. 自動的にソルト生成とハッシュ化を実行
4. ハッシュ化されたパスワード文字列を返却
5. データベースに保存する際はこのハッシュ値を使用

#### パスワード検証処理
**VerifyPassword メソッドの処理内容**:
1. 平文パスワードとハッシュ値を受け取り
2. BCrypt.Net.BCrypt.Verifyメソッドで検証実行
3. 平文パスワードを同じアルゴリズムでハッシュ化
4. 保存されているハッシュ値と比較
5. 一致する場合はtrue、不一致の場合はfalseを返却

### 6.2 パスワードポリシー
- **最小文字数**: 6文字以上
- **文字種**: 英数字（将来的に記号も含める検討）
- **禁止パスワード**: 一般的なパスワード（将来実装）
- **履歴管理**: パスワード変更履歴（将来実装）

## 7. 認可制御

### 7.1 Authorize 属性
```csharp
// 認証が必要なエンドポイント
[Authorize]
public class OrdersController : ControllerBase
{
    // 認証済みユーザーのみアクセス可能
}

// 管理者権限が必要なエンドポイント
[Authorize(Roles = "Admin")]
public class AdminController : ControllerBase
{
    // 管理者のみアクセス可能
}
```

### 5.3 認可制御処理設計

#### 管理者権限チェックの処理フロー
**Controller内での実装手順**:
1. **クレーム取得**: HttpContext.User.FindFirst(ClaimTypes.NameIdentifier)でユーザーIDクレームを取得
2. **値検証**: クレーム値が存在し、int.TryParseで整数に変換可能かチェック
3. **変換失敗時**: 無効な場合はfalseを返却（権限なし）
4. **ユーザー検索**: ECShopContextを使用してUsersテーブルから指定IDのユーザーを検索
5. **権限確認**: ユーザーが存在し、IsAdminプロパティがtrueの場合のみtrueを返却
6. **使用場面**: 管理者権限が必要なActionの冒頭で実行

#### 現在ユーザーID取得の処理フロー
**Controller内での実装手順**:
1. **クレーム取得**: HttpContext.User.FindFirst(ClaimTypes.NameIdentifier)でユーザーIDクレームを取得
2. **デフォルト値設定**: クレームが存在しない場合は"0"をデフォルト値として使用
3. **型変換**: int.Parseまたはint.TryParseで文字列を整数に変換して返却
4. **使用場面**: 認証済みユーザーのIDが必要な処理（注文作成、注文履歴取得等）で使用
5. **注意点**: [Authorize]属性で認証済み前提のため、通常はクレームが存在する

### 5.4 ビジネスロジック設計方針

#### 認証処理の責務
- **パスワードハッシュ化**: BCrypt.Net.BCrypt.HashPassword使用
- **パスワード検証**: BCrypt.Net.BCrypt.Verify使用
- **JWT生成**: JwtSecurityTokenHandler使用
- **ユーザー重複チェック**: データベースでの一意性確認

#### セキュリティ考慮事項
- **パスワード平文保存禁止**: 必ずBCryptハッシュ化
- **JWT秘密鍵管理**: appsettings.jsonで設定、本番環境では環境変数推奨
- **クレーム情報**: 最小限の情報のみ含める
- **トークン有効期限**: 適切な期間設定（デフォルト24時間）

## 8. フロントエンド認証

### 8.1 認証サービス (authService.js)
```javascript
class AuthService {
  constructor() {
    this.baseURL = 'http://localhost:5000/api/auth';
    this.tokenKey = 'auth_token';
    this.userKey = 'user_info';
  }

  // ログイン
  async login(username, password) {
    const response = await fetch(`${this.baseURL}/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ username, password })
    });

    if (!response.ok) {
      throw new Error('ログインに失敗しました');
    }

    const data = await response.json();
    this.setToken(data.token);
    this.setUser(data.user);
    return data;
  }

  // ユーザー登録
  async register(userData) {
    const response = await fetch(`${this.baseURL}/register`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(userData)
    });

    if (!response.ok) {
      throw new Error('登録に失敗しました');
    }

    const data = await response.json();
    this.setToken(data.token);
    this.setUser(data.user);
    return data;
  }

  // ログアウト
  logout() {
    localStorage.removeItem(this.tokenKey);
    localStorage.removeItem(this.userKey);
  }

  // トークン管理
  setToken(token) {
    localStorage.setItem(this.tokenKey, token);
  }

  getToken() {
    return localStorage.getItem(this.tokenKey);
  }

  // ユーザー情報管理
  setUser(user) {
    localStorage.setItem(this.userKey, JSON.stringify(user));
  }

  getUser() {
    const user = localStorage.getItem(this.userKey);
    return user ? JSON.parse(user) : null;
  }

  // 認証状態チェック
  isAuthenticated() {
    const token = this.getToken();
    if (!token) return false;

    // JWT の有効期限チェック（簡易版）
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      return payload.exp * 1000 > Date.now();
    } catch {
      return false;
    }
  }

  // 管理者チェック
  isAdmin() {
    const user = this.getUser();
    return user && user.isAdmin;
  }

  // 認証ヘッダー取得
  getAuthHeader() {
    const token = this.getToken();
    return token ? { Authorization: `Bearer ${token}` } : {};
  }
}

export default new AuthService();
```

### 8.2 ログインフォーム (LoginForm.vue)
```vue
<template>
  <div class="login-form">
    <form @submit.prevent="handleLogin">
      <div class="mb-3">
        <label for="username" class="form-label">ユーザー名</label>
        <input
          type="text"
          class="form-control"
          id="username"
          v-model="form.username"
          required
        />
      </div>
      <div class="mb-3">
        <label for="password" class="form-label">パスワード</label>
        <input
          type="password"
          class="form-control"
          id="password"
          v-model="form.password"
          required
        />
      </div>
      <button type="submit" class="btn btn-primary" :disabled="loading">
        <span v-if="loading" class="spinner-border spinner-border-sm me-2"></span>
        ログイン
      </button>
    </form>
    <div v-if="error" class="alert alert-danger mt-3">
      {{ error }}
    </div>
  </div>
</template>

<script>
import authService from '../services/authService';

export default {
  name: 'LoginForm',
  data() {
    return {
      form: {
        username: '',
        password: ''
      },
      loading: false,
      error: null
    };
  },
  methods: {
    async handleLogin() {
      this.loading = true;
      this.error = null;

      try {
        await authService.login(this.form.username, this.form.password);
        this.$emit('login-success');
        // ページリロードまたはリダイレクト
        window.location.reload();
      } catch (error) {
        this.error = error.message;
      } finally {
        this.loading = false;
      }
    }
  }
};
</script>
```

### 8.3 認証ガード
```javascript
// ルートガード例
const requireAuth = (to, from, next) => {
  if (authService.isAuthenticated()) {
    next();
  } else {
    next('/login');
  }
};

const requireAdmin = (to, from, next) => {
  if (authService.isAuthenticated() && authService.isAdmin()) {
    next();
  } else {
    next('/');
  }
};

// Vue Router設定
const routes = [
  {
    path: '/profile',
    component: UserProfile,
    beforeEnter: requireAuth
  },
  {
    path: '/admin',
    component: AdminDashboard,
    beforeEnter: requireAdmin
  }
];
```

## 9. エラーハンドリング

### 9.1 認証エラー
```csharp
public static class ErrorMessages
{
    public static class Authentication
    {
        public const string USERNAME_ALREADY_EXISTS = "ユーザー名が既に存在します";
        public const string EMAIL_ALREADY_EXISTS = "メールアドレスが既に存在します";
        public const string INVALID_CREDENTIALS = "認証情報が無効です";
        public const string ADMIN_REQUIRED = "管理者権限が必要です";
        public const string TOKEN_EXPIRED = "トークンの有効期限が切れています";
        public const string TOKEN_INVALID = "無効なトークンです";
    }
}
```

### 9.2 フロントエンドエラー処理

#### API リクエスト時の認証エラー処理
**apiRequest 関数の処理内容**:
1. **ヘッダー設定**
   - Content-Typeをapplication/jsonに設定
   - authService.getAuthHeader()でJWTトークンを取得してAuthorizationヘッダーに設定
   - 追加のヘッダーがあれば統合

2. **リクエスト送信**
   - fetchAPIを使用してHTTPリクエストを送信
   - 設定したヘッダーとオプションを適用

3. **ステータスコード別エラー処理**
   - **401 Unauthorized**: 認証エラー
     - authService.logout()でローカルストレージをクリア
     - ログインページにリダイレクト
     - 「認証が必要です」エラーをスロー
   - **403 Forbidden**: 権限エラー
     - 「権限がありません」エラーをスロー
   - **その他のエラー**: HTTPステータスとメッセージを含むエラーをスロー

4. **成功時処理**: レスポンスをJSON形式で返却

## 10. セキュリティ考慮事項

### 10.1 JWT セキュリティ
- **秘密鍵**: 十分に長く複雑な秘密鍵を使用
- **有効期限**: 適切な有効期限設定（24時間）
- **リフレッシュトークン**: 将来実装予定
- **トークン無効化**: ログアウト時の処理（将来実装）

### 10.2 パスワードセキュリティ
- **ハッシュ化**: BCrypt使用
- **ソルト**: BCryptが自動生成
- **平文保存禁止**: パスワードは必ずハッシュ化
- **強度チェック**: 将来的にパスワード強度チェック実装

### 10.3 セッション管理
- **localStorage**: 現在の実装（XSS脆弱性あり）
- **httpOnly Cookie**: 将来的に検討
- **CSRF対策**: 将来実装予定
- **セッション固定攻撃対策**: JWT使用により軽減

### 10.4 入力検証
- **サーバーサイド**: 厳密なバリデーション
- **クライアントサイド**: ユーザビリティ向上
- **SQLインジェクション**: Entity Framework使用
- **XSS**: Vue.jsの自動エスケープ

## 11. テスト設計

### 11.1 単体テスト設計

#### AuthController テスト設計

**Register_ValidUser_ReturnsAuthResponse テスト**
- **目的**: 有効なユーザーデータでの登録が成功することを確認
- **準備**: 
  - 有効なRegisterRequestオブジェクトを作成
  - ユーザー名、メール、パスワード、氏名を設定
- **実行**: AuthController.Registerメソッドを呼び出し
- **検証**:
  - HTTPステータス200（OK）が返されること
  - AuthResponseオブジェクトが返されること
  - JWTトークンが生成されていること
  - ユーザー情報が正しく設定されていること

**Login_InvalidCredentials_ReturnsBadRequest テスト**
- **目的**: 無効な認証情報でのログインが失敗することを確認
- **準備**:
  - 存在しないユーザー名と間違ったパスワードでLoginRequestを作成
- **実行**: AuthController.Loginメソッドを呼び出し
- **検証**:
  - HTTPステータス400（Bad Request）が返されること
  - 認証エラーメッセージが含まれること
  - JWTトークンが生成されないこと

### 11.2 統合テスト設計

#### 認証フロー統合テスト

**AuthFlow_RegisterAndLogin_Success テスト**
- **目的**: ユーザー登録からログインまでの一連の流れが正常に動作することを確認
- **準備**:
  - テスト用HTTPクライアントを作成
  - 有効なRegisterRequestオブジェクトを用意
- **実行**:
  - **登録処理**: POST /api/auth/register エンドポイントにリクエスト送信
  - **登録確認**: レスポンスが成功ステータスであることを確認
  - **ログイン処理**: 登録したユーザー情報でPOST /api/auth/login にリクエスト送信
- **検証**:
  - ログインレスポンスが成功ステータスであること
  - AuthResponseオブジェクトが正しく返されること
  - JWTトークンが生成されていること
  - ユーザー情報が正しく含まれていること
- **特徴**: 実際のHTTPリクエスト/レスポンスを通じた統合テスト

### 11.3 フロントエンドテスト設計

#### AuthService テスト設計

**login stores token and user info テスト**
- **目的**: ログイン成功時にトークンとユーザー情報が正しく保存されることを確認
- **準備**:
  - モックレスポンスオブジェクト（token, user）を作成
  - global.fetchをモック化して成功レスポンスを返すよう設定
- **実行**: authService.loginメソッドを呼び出し
- **検証**:
  - localStorageの'auth_token'キーにトークンが保存されること
  - localStorageの'user_info'キーにユーザー情報がJSON形式で保存されること
  - 保存された値が期待値と一致すること

**isAuthenticated returns false for expired token テスト**
- **目的**: 有効期限切れのトークンで認証状態がfalseになることを確認
- **準備**:
  - 有効期限が過去の日時に設定されたJWTトークンを作成
  - localStorageにそのトークンを保存
- **実行**: authService.isAuthenticatedメソッドを呼び出し
- **検証**:
  - 戻り値がfalseであること
  - 有効期限チェック機能が正常に動作すること

## 12. 運用・監視

### 12.1 ログ出力設計

#### 認証関連ログ出力方針
**ログイン処理でのログ出力内容**:

1. **ログイン試行ログ**
   - ログレベル: Information
   - 出力タイミング: ログイン処理開始時
   - 出力内容: 「Login attempt for user: {Username}」
   - 目的: ログイン試行の監査証跡

2. **ログイン成功ログ**
   - ログレベル: Information
   - 出力タイミング: 認証成功・トークン生成後
   - 出力内容: 「User {Username} logged in successfully」
   - 目的: 正常ログインの記録

3. **ログイン失敗ログ**
   - ログレベル: Warning
   - 出力タイミング: 例外発生時（catch句内）
   - 出力内容: 「Login failed for user: {Username}. Error: {Error}」
   - 目的: 不正アクセス試行の検出・分析

4. **セキュリティ考慮事項**
   - パスワードは絶対にログ出力しない
   - 失敗理由の詳細はログのみに記録
   - クライアントには汎用的なエラーメッセージを返却

### 12.2 セキュリティ監視
- **ログイン失敗回数**: 異常なログイン試行の検出
- **新規登録数**: 異常な登録パターンの検出
- **トークン使用状況**: 異常なAPI使用パターンの検出
- **管理者操作**: 管理者権限の使用状況監視

### 12.3 メトリクス
- **アクティブユーザー数**: 日次・月次
- **ログイン成功率**: 認証システムの健全性
- **セッション継続時間**: ユーザー行動分析
- **権限昇格**: セキュリティ監査

## 13. 今後の拡張予定

### 13.1 セキュリティ強化
- **リフレッシュトークン**: 長期認証の実装
- **多要素認証**: SMS・メール認証
- **OAuth連携**: Google・Facebook ログイン
- **パスワードレス認証**: WebAuthn対応

### 13.2 機能拡張
- **プロフィール編集**: ユーザー情報更新
- **パスワード変更**: セキュアなパスワード更新
- **アカウント削除**: GDPR対応
- **ログイン履歴**: セキュリティ監査

### 13.3 運用改善
- **レート制限**: ブルートフォース攻撃対策
- **アカウントロック**: 異常ログイン検出
- **監査ログ**: 詳細なセキュリティログ
- **コンプライアンス**: GDPR・個人情報保護法対応
